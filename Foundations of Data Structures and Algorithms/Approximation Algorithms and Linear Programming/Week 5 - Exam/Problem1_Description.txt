I would like to solve a linear programming problem using Pulp library in python. The problem contains a graph of "n" cities as vertices, an edge_list containing a lis of (i,j,c)  which the cost of transportation of oil from city "i" to city "j", in both directions, with a cost of transportation "c", and a list of supplies for each city. The supplies list can contain positive or negative values. Positive values mean supply and negative values mean demand.  We need to minimize the overall transportation cost which is the sum of cost of selected edges time the flow. We also need to satisfy the following constraints:

Constraint #1: For each city with a net oil demand, the total inflow of oil into the city minus the total outflow of oil from the city must be equal to the total demand of the city.

constraint #2: For each city with a net oil supply, the total outflow of oil from the city minus the total inflow into the city must be less than or equal to the net supply available for the city. 
 
Your function must return a dictionary that maps edges "(i,j)" to the flow along the edge in the direction i towards j.
  Requirement #1: All flows  must be non-negative.
  
  Requirement #2: If you specify a flow from $j$ to $i$, then your dictionary must have the key "(j,i)" mapped to the non-negative flow from j towards i.
  
  Requirement #3: If an edge is not present in the dictionary, we will take the flow along it to be zero.

Here is the "calculateOptimalPlan" function to be completed:

from pulp import *
def calculateOptimalPlan(n, edge_list, supplies, debug=False):
    assert n >= 1
    assert all( 0 <= i < n and 0 <= j < n and i != j and c >= 0 for (i,j,c) in edge_list)
    assert len(supplies) == n

    
And here is the function that tests functionality of "calculateOptimalPlan" :

def test_solution(n, edge_list, supplies, solution_map, expected_cost):
    cost = 0
    outflows = [0]*n
    inflows = [0]*n
    for (i,j,c) in edge_list:
        if (i,j) in solution_map: 
            flow = solution_map[(i,j)]
            cost += c * flow
            assert flow >= 0, f'flow on edge {(i,j)} is negative --> {flow}'
            outflows[i] += flow 
            inflows[j] += flow
        elif (j,i) in solution_map:
            flow = solution_map[(j,i)]
            cost += c * flow
            assert flow >= 0, f'flow on edge {(j,i)} in negative --> {flow}'
            outflows[j] += flow
            inflows[i] += flow 
    for (i, s) in enumerate(supplies):
        if s > 0:
            assert outflows[i]  - inflows[i] <= s, f'Vertex {i} constraint violated: total outflow = {outflows[i]} inflow = {inflows[i]}, supply = {s}'
        else:
            assert abs(inflows[i]-outflows[i] + s) <= 1E-2,f'Vertex{i} constraint violated: inflow = {inflows[i]} outflow={outflows[i]}, demand = {-s}'
    if expected_cost != None:
        assert abs(expected_cost - cost) <= 1E-02, f'Expected cost: {expected_cost}, your algorithm returned: {cost}'
    print('Test Passed!')

n = 5
edge_list = [
    (0,1, 5), (0, 3, 3), (0, 4, 4),
    (1,2, 9), (1,4, 6),
    (2,3,8),
    (3,4,7)
]
supplies = [-55, 100, -25, 35, -40]
sol_map = calculateOptimalPlan(n, edge_list, supplies, debug=True)
test_solution(n, edge_list, supplies, sol_map,670)





