We are given n continuous variables within Ranges [li, ui], and m inequalities. Each 
inequality I𝑗 is of the form:

I𝑗:𝑐𝑗1*𝑥1+⋯+𝑐𝑗𝑛*𝑥𝑛≤𝑑𝑗

Given that each  𝑥𝑖∈[l𝑖,u𝑖] are the bounds for each variable  𝑥𝑖 , 
let  𝗎𝗉𝗉𝖾𝗋𝖡𝗈𝗎𝗇𝖽𝖫𝖧𝖲(I𝑗) denote the maximum value that the LHS Expression  
𝑐𝑗1𝑥1+⋯+𝑐𝑗𝑛𝑥𝑛 takes in the domain  𝑥1∈[l1,u1],…,𝑥𝑛∈[l𝑛,u𝑛].


For each inequality 𝐼𝑗:𝑐𝑗1*𝑥1+⋯+𝑐𝑗𝑛*𝑥𝑛≤𝑑𝑗, we convert it into the following 
inequality 𝐼̂ 𝑗: 𝑐𝑗1*𝑥1+⋯+𝑐𝑗𝑛*𝑥𝑛≤𝑑𝑗*𝑤𝑗+𝑀𝑗*(1−𝑤𝑗) where 𝑀𝑗=𝗎𝗉𝗉𝖾𝗋𝖡𝗈𝗎𝗇𝖽𝖫𝖧𝖲(𝐼𝑗) . 
Prove that 𝐼̂ 𝑗 is the same as 𝐼𝑗 when 𝑤𝑗=1 and 𝐼̂ 𝑗 is implied by the other 
constraints when 𝑤𝑗=0 . In fact, we need to maximize 𝑤1+⋯+𝑤𝑚.

We would like to implement the mixed integer linear programming above using python by completing a function solveForMaximumInequalitySatisfaction with the following 
arguments:

Input #1: "n" the number of variables 

Input #2: "m" the number of inequalities 

Input #3: "c_matrix" which is a list of list of coefficients of the LHS of inequalities,
in a form like this:

c_matrix = 
[
    [c11,...,c1n],
    [c21,...,c2n],
    ...
    [cm1,...,cmn],
]

Please note python indexes starting from 0. 

Input #4: "d_values" which is a list of RHS coefficients, 
in a form like this:
d_values = [𝑑1,…,𝑑𝑚] 

Input #5: "bounds" which is a list of pairs  [(I1,u1),…,(I𝑛,u𝑛)] for each variable. 


Your function should return a pair:  (𝑘,[𝑥1,…,𝑥𝑛]). In which: 
- 𝑘 is the number of inequalities satisfied by your optimal solution
- [𝑥1,…,𝑥𝑛]  is a list denoting the values of 𝑥1,…,𝑥𝑛 that satisfy the 𝑘 inequalities.

# Here is a useful function to implement the LHS upper bound that we need for the encoding
def lhsUpperBound(c_list, bounds):
    n = len(c_list)
    assert len(bounds) == n 
    upper_bnd = sum([(cj*lj) if cj < 0 else cj*uj for (cj, (lj, uj)) in zip(c_list, bounds) ])
    return upper_bnd

Use Pulp library to implement the solution in python by completing the following function:

def solveForMaximumInequalitySatisfaction(n, m, c_matrix, d_values, bounds):
    # always check pre-conditions: saves so much time later
    assert len(c_matrix) == m
    assert all(len(c_list) == n for c_list in c_matrix)
    assert len(d_values) == m
    assert len(bounds) == n
    assert all (lj <= uj for (lj, uj) in bounds)
    ## TODO: set up and solve the problem for satisfying the maximum number of inequalities
    # your code here








====================================================================================

Now we want create a huristic algorithm, without mixed integer programming, 
that satisfies at least m/2 of constraints.

Generate 𝑛 random numbers 𝑟1,…,𝑟𝑛 in some range [−1,1] and simply substitute: 
𝑥1=𝑟1*𝑥,
𝑥2=𝑟2*𝑥,
…,
𝑥𝑛=𝑟𝑛*𝑥 
where 𝑥 is a new unknown variable. 

Now, if we partition the inequalities into two subsets: 

Subset #1: All inequalities with a positive coefficient for 𝑥, which are:
𝑥≤𝑑𝑖1,…,𝑥≤𝑑𝑖𝑚 By setting  𝑥=max(𝑑𝑖1,…,𝑑𝑖𝑚) we can satisfy all 
these inequalities. 

Subset #2: All inequalities with a negative coefficient for 𝑥, which are: 
−𝑥≤𝑑𝑗1,…,−𝑥≤𝑑𝑗𝑚 

At least one of these partitions must account for  𝑚/2 or more constraints.

Using the algorithm for 𝑛=1 variables, implement an algorithm that 
achieves a factor-2 approximation for inequalities with arbitrary 𝑛. 
Specifically, given a system of 𝑚 inequalities over 𝑥1,…,𝑥𝑛 , 
provide an algorithm that finds a solution (𝑥1,…,𝑥𝑛) that satisfies ≥𝑚/2 inequalities.


Complete function below to implement the algorithm:

from random import uniform 

def computeApproximateSolution(n, m, c_matrix, d_values):
    assert n >= 1
    assert len(c_matrix) == m
    assert all(len(c_list) == n for c_list in c_matrix)
    assert len(d_values) == m
    r_values = [uniform(-1, 1) for i in range(n)]
    # your code here
